% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/har_shape - Copy.R, R/har_shape.R
\name{har_shape}
\alias{har_shape}
\title{Merge and generate new headers.}
\usage{
har_shape(
  input_data,
  new_calculated_vars = NULL,
  del_headers = NULL,
  export_sets = T,
  output_har_file = NULL
)

har_shape(
  input_data,
  new_calculated_vars = NULL,
  del_headers = NULL,
  export_sets = T,
  output_har_file = NULL
)
}
\arguments{
\item{input_data}{It must consist of one or more input databases, which must be separated from each other by sublists (see example). In the case of multiple databases, all will be combined for the final output.Arrays and data.frames must be inside sublists (list(....)) as indicated in the examples section. Aggregations on input data can only be performed on single array and data.frame inputs.}

\item{new_calculated_vars}{New variables resulting from custom calculations between the headers contained in input_data. The header_name[c("its sets")] format must be adopted. The new header generated by the calculation will be aggregated by sum in the sets indicated for it. Please check the examples section and the package's online manual for more details.}

\item{del_headers}{Vector of characters with the names of headers that must be excluded from the output.}

\item{export_sets}{If a name for a .har file is indicated, all sets will exported to that .har file. If TRUE the sets will included in output_har_file, if FALSE the sets will not be written anywhere. (default = TRUE)}

\item{output_har_file}{Output .har file name.}
}
\description{
Allows the combination of different databases in data.frame or array format. Generate new variables flexibly from custom functions. Calculations can be performed between headers/variables of different dimensions/sets.

Allows the combination of different databases in data.frame or array format. Generate new variables flexibly from custom functions. Calculations can be performed between headers/variables of different dimensions/sets.
}
\note{
Bear in mind that, for performance reasons, before carrying-out custom calculations between different Headers with different sets, the function aggregates all headers involved in the computation to the output set. That is, in a MAKE(COM, IND)/1CAP(COM) division operation, the first operation is the aggregation for MAKE(COM), and only then is the division calculation processed. 
Therefore, for example, a weighted average aggregation cannot be done directly. It is recommended to use the agg_har function in this case.

1. The calculations indicated in the new_calculated_vars variable are processed sequentially. Therefore, if the calculation for generating a new header depends on another header that will also be generated within new_calculated_vars, the second one must be defined first.
2. Ensure that the .har files adopted as input_data have an adequate structure, including the declaration of sets for each file header. It prevents the output_har_file from being recorded with errors that make it impossible for the file to be opened by the Viewhar software later.
}
\examples{
# example code

# -Reads list_df, a list of input data (data.frame(1), list of arrays(2), array(3)) >
# -Aggregates the input (1) for "MAR1" in 3 sets by simple addition (default) >
# -Aggregates the input(3) for "XPLC" into 1 set per average >
# -Deletes headers "MAR1" and "3pur" >
# -Saves the output in a .har file ("gtaptools_shape_example1.har") >
# -Returns the list of "binded_df" arrays.

list_df <- list(
 list(
   input_data = gtaptools::example_df, # 1 - data.frame
   sets = c("COM", "SRC", "MAR"), # sum on IND
   col_values = "Freq",
 new_header_name = "MAR1"
),
gtaptools::example_arrays_har, # 2 - list of arrays
 list(
   input_data = gtaptools::example_arrays_har$xplh, # 3 - array
   sets = c("COM"), # sum in HOU,
   fun = function(x) mean(x),
   new_header_name = "XPLC"
)
) 

binded_df <-
  gtaptools::har_shape(
    input_data = list_df,
    del_headers = c("MAR1", "3pur"),
    output_har_file = "gtaptools_shape_example1.har"
  )


















# example code

# - The list_df is composed by list_df, a list of input data (data.frame(1), list of arrays(2), array(3)) >

list_df <- list(
  list(
    input_data = gtaptools::example_df, # 1 - data.frame
    header = quote(`1MAR`[c("COM", "SRC", "IND", "MAR")])
  ),
  gtaptools::example_arrays_har, # 2 - list of arrays
  list(
    input_data = gtaptools::example_arrays_har$XPLH, # 3 - array
    header = quote(`XPLH`[c("COM", "HOU")])
  )
)

calcs defines the calculations that aggregate (1), solve a matrix (2) and create a header (3).

calcs <- list(
  quote(MARC["COM"] := `1MAR`), # Sum to set COM
  quote(MULT[c("REG", "HOU")] := solve(MAKE)), # solve the matrix
  quote(NSET := c("Comm1", "Comm2")) # Creating sets
)


new_binded_df is a list object that combines the databases contained in list_df and the calculations described in calcs.
 Also, the "3PUR" header will not be included in the data output to "gtaptools_shape_example1.har", while the sets are being written to "gtaptools_shape_example1_sets.har"


new_binded_df <-
  gtaptools::har_shape(
    input_data = list_df,
    new_calculated_vars = calcs,
    del_headers = c("3PUR"),
    export_sets = "gtaptools_shape_example1_sets.har"
    output_har_file = "gtaptools_shape_example1.har"
  )


















}
